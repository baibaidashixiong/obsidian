### 前言
- **bootstraping**：一句话概括就是通过自己的引导将自己拉起来。如可以用Java实现自己的编译器，但是却不能用Java来编译用Java实现的编译器（存疑，为什么？），而应该先用其它的语言编译一次。之后就可以用编译好的编译器来编译它自己的未来版本。编译类似GCC的工具链也是如此。
- **解释器的工作流程**：
	1. 词法分析：将无意义的字母去除空格，注释后变为有意义的单词，符号等。
	2. 解析：将第一步所得的单词记号解析成抽象语法树。
	3. 静态分析：将每一个标识符与其定义类型绑定在一起（作用域），一旦检查出两种不同类型/不支持相互添加的变量同时一起计算就可以发现错误。（前端部分）
	4. 中间表示 Intermediate representations( IR )：为每种不同的语言编写一个前端，然后为每一种目标架构提供一个后端，如果每一个前端都能转换成遵守同样规则的中间端，那解释器的后端就可以进行复用了。
	5. 优化：一个常见的例子就是常量折叠，如在编译同时对某个式子进行计算并赋值给变量。
	6. （机器）代码生成：早期此步是直接生成对应架构的机器代码，但是这样会导致不同架构间编译器的可移植性不高。如今的解释器在此步通常是生成字节码（一种可移植到不同架构的中间代码，每一条指令通常只有一个字节的长度），由此提高后端的可移植性。
	7. 虚拟机：如果编译器在上一步生成的是字节码，那么该步的步骤就会变得简单，可以为每一个目标架构编写一个字节码到对应目标架构的小型编译器，以字节码作为中间表示就能大大简化流程。或者也可以编写一个用自己的虚拟架构的虚拟机（VM），字节码便可以直接运行在此虚拟机上（这也是JVM的设计思想）虽然此种方法简单便携，兼容性好，但是此种方法效率比较低，因为每条指令每次执行时都必须在运行时进行模拟。
	8. 运行：通常在程序运行时需要语言提供一些额外的服务。如GC（Garbage Collection），instance of来获取对象的类型。这些东西都被称为runtime。在一次编译所有代码的语言中，实现运行时的代码直接插入生成的可执行文件中。例如，在 Go 中，每个编译的应用程序都有自己的 Go 运行时副本直接嵌入其中。如果语言在解释器或 VM 中运行，那么runtime就是在编译的过程中，这就是 Java、Python 和 JavaScript 等语言的大体实现方式。
- **即时编译（Just-in-time compilation）**：由于执行代码最快的方法是将其编译为机器代码，而且可能不知道最终用户的机器支持什么架构。此时就可以做与 HotSpot JVM、Microsoft 的 CLR 和大多数 JavaScript 解释器做的相同的事情。在最终用户的机器上，当程序加载时——无论是从 JS 的源代码，还是 JVM 和 CLR 的独立于平台的字节码——将它编译为本地计算机支持的体系结构。这被称为即时编译（JIT）。最复杂的JIT会在生成的代码中插入profiling hooks，以查看哪些代码区域对性能影响最为关键，以及哪些类型的数据流经这些区域。然后，随着时间的推移/分析的增多，他们将自动重新编译那些具有更高级优化的热点。
- **编译器和解释器**：
	- 首先解释**编译**：编译是一种实现技术，指的是将源代码翻译成低级语言，如字节码或机器码；或是转译成其它高级语言也被称为编译。
	- **编译器**的意思是它将源代码翻译成其他形式但不执行它。用户必须获取结果输出并自己运行。而**解释器**是指读取程序的源代码并立即执行，即从源代码运行程序。
	- 编译器和解释器有交集，GCC 和 Clang 通过获取 C 代码并将其编译为机器代码，使得用户可以直接运行该可执行文件。所以它们是 C 的编译器。在 Matz 的 Ruby 规范实现的旧版本中，用户从源代码运行 Ruby，通过遍历语法树的方式直接解析并执行。除此之外没有其它编译的流程，这就是 Ruby 的解释器。但是 对于CPython来说，当用户使用它运行 Python 程序时，代码会被解析并转换为内部字节码格式，然后在 VM 内执行。 所以CPython 既是一个解释器又是一个编译器。实际上大多数脚本语言都是这样的，如下图所示：
![[编译器与解释器的界限.png]]
### Zox语言的设计与实现
#### 1.设计思想
为了达到Zox语言小而有用的目的，将JavaScript的特点和语法作为实现参考，其有以下两个方面的特点：
- **动态类型**：Zox的变量可以存储任何类型的值，单个变量甚至可以存储不同时间不同类型的值。当对错误类型的值执行操作（例如，将数字除以字符串），则会在运行时检测并报告错误。选择Zox变量为动态类型的一大原因就是方便，静态类型系统在编译时需要大量的实现工序和步骤。如果我们将类型检查推迟到运行时，我们将更快速方便的启动解释器并执行一些代码。
- **自动内存管理**：低级语言中的内存管理会消耗程序员很多不必要的时间。所以Zox也应该具备自动内存管理的功能。有两种主要的内存管理技术：引用计数（待补充）和跟踪垃圾收集（通常简称“garbage collection(GC)”）。Perl、PHP 和 Python 开始都使用引用计数器的一大原因就是它的实现较为简单。但是，随着时间的推移，引用计数的局限性开始显现。所以这些语言最终都添加了一个完整的 GC，或者至少添加了一个足以清理对象循环的垃圾回收器。

#### 2.数据类型
Zox中主要包含以下
- 布尔型：true，false。
- 数字：Zox中只有双精度浮点数（也包含着整数）
- 字符串：虽然字符串看起来简单，但是在实现的过程中会相当复杂。
- nil：即null，为了与其它语言进行区分。
由于空指针会对系统造成许多难以预料/解决的问题，所以有充分的理由不设置空值。对于静态类型语言来说禁止它是有很大的好处的。但是，在动态类型的语言中，将其完全去除会比将其启用有更多更麻烦的问题。（为什么？）

#### 3.表达式
- **算数**：二元运算符两边的是操作数。因为运算符固定在操作数的中间，所以这些运算符也称为中缀运算符，而不是运算符之前和后缀的前缀运算符它跟随操作数的地方。一个算术运算符实际上既是中缀又是前缀。运算符也可用于否定数字：
```Zox
-negateMe;
add + me;
subtract - me;
multiply * me;
divide / me;
```
- **比较运算符**：此种运算符主要返回布尔结果类型。
```Zox
less < than;
lessThan <= orEqual;
greater > than;
greaterThan >= orEqual;
//也可以测试任何类型的两个值是否相等
1 == 2; // false. 
"cat" != "dog"; // true.
314 == "pi"; // false.
123 == "123"; // false.不同类型的两个值永远不想等
```
- **逻辑运算符**：and左操作数为假时直接跳过右操作数，or的左操作数为真时直接跳过右操作数。
```Zox
!true; // false. 
!false; // true.
true and false; // false. 
true and true; // true.
false or false; // false. 
true or false; // true.
```
- **优先级和分组**：Zox中对数据的处理顺序与C相同。
```Tox
var average = (min + max) / 2;
```
- **陈述**：
```Zox
print "Hello, world!";
"some expression";
{ print "One statement."; print "Two statements."; }
//块语句也会影响作用于域
```
- **变量**：由于是动态类型的语言，Zox中统一用var定义变量，未赋值的变量默认为nil：
```Zox
var imAVariable = "here is my value"; 
var iAmNil;
var breakfast = "bagels"; 
print breakfast; // "bagels". 
breakfast = "beignets"; 
print breakfast; // "beignets".
```
- **控制流**：Zox中主要有三种控制流，if else，while，和for。
- **函数**：函数调用必须要带有`()`，不加括号就只是引用（不执行）。如果执行到函数块结尾时候都没有`return`，那么它会隐式的返回`nil`。
```Zox
makeBreakfast(bacon, eggs, toast);
makeBreakfast();
fun printSum(a, b) { print a + b; }
```
- **闭包**：即创建一个数据结构，将功能代码及其所需的周围变量捆绑在一起，闭包的意思就是为它关闭并保留所需的变量。在下面的函数中，inner() 必须“保留”对它使用的任何周围变量的引用，以便即使在外部函数返回后它们仍然存在。我们调用执行此闭包的函数。可以想象，实现这些会增加一些复杂性，因为我们不能再假设变量范围严格地像堆栈一样工作，在堆栈中局部变量在函数返回时消失。
```Zox
fun returnFunction() { 
	var outside = "outside"; 
	fun inner() { 
		print outside; 
	} 
	return inner; 
} 
var fn = returnFunction(); 
fn();
```
- **类**：在具体解释该特性以前回答两个问题：
	- 为什么任何语言都希望是面向对象的？
		- 方便。特别是对于动态类型语言，对象非常方便。我们需要某种方式来定义复合数据类型，以便将大量数据捆绑在一起。如果我们也可以将方法挂在这些方法之外，那么我们就不需要在所有函数前加上它们所操作的数据类型的名称，以避免与不同类型的相似函数发生冲突。
	- 面向对象用类还是原型（Classes or prototypes）？
		- 对象实际上有两种方法，类和原型。而在JavaScript出现前用原型的语言极少。在基于类的语言中，有两个核心概念：实例和类。实例存储每个对象的状态并引用实例的类。类包含方法和继承链。要在实例上调用方法，总会有一个间接级别。可以通过查找实例的类来找到其中的方法。**基于原型**的语言合并了这两个概念。只有对象没有类——每个单独的对象都可能包含状态和方法。对象可以直接相互继承（或用原型术语“委托”）虽然原型语言比类更基础且易于实现，但是许多用原型语言编写的代码，人们通常用它的便捷和灵活来重塑类...
- **在Zox中的类**：
```Zox
class Breakfast{
	...
}
// 类声明，将类存储到变量中
var someVariable = Breakfast; 
// 将类作为参数输入到函数中
someFunction(Breakfast);
// 类的实例化
var breakfast = Breakfast(); 
print breakfast; // "Breakfast 实例"
```
- **实例化和初始化**：面向对象编程背后的思想是将行为和状态封装在一起。字段应运而生。
（1）Zox允许自由的向对象添加属性。如果该字段不存在，则会创建一个字段并分配。
（2）使用`this`来获取当前对象的字段或方法。
（3）在对象中封装数据的一部分是确保对象在创建时处于有效状态。定义一个初始化函数`init()`，在构造对象时会自动调用该方法。传递给该类的任何参数都将转发给它的初始化程序。
```Zox
>>> (1)
breakfast.meat = "sausage"; 
breakfast.bread = "sourdough";
>>> (2)
class Breakfast { 
	serve(who) { 
			print "Enjoy your " + this.meat + " and " +
				this.bread + ", " + who + "."; 
	} 
	// ... 
}
>>> (3)
class Breakfast { 
	init(meat, bread) { 
		this.meat = meat; 
		this.bread = bread; 
	} 
	// ... 
} 
var baconAndToast = Breakfast("bacon", "toast"); 
baconAndToast.serve("Dear Reader"); 
// 输出 "Enjoy your bacon and toast, Dear Reader."
```
- **继承**：每种面向对象的语言不仅可以自己定义方法，还可以在多个类或对象中重用它们。为此，Zox 支持单继承。
（1）当声明一个类时，可以使用小于 ( < ) 运算符指定它继承自的类。
（2）在例1中，Brunch 是子类，Breakfast 是基类或超类或父类。超类中定义的每个方法也可用于其子类。
（3）甚至 init() 方法也会被继承。实际上，子类通常也想定义自己的 init() 方法。但是还需要调用原始类，以便超类可以保持其状态。我们需要一些方法来在我们自己的实例上调用一个方法而不用调用我们自己的方法。可以用super方法来实现。
	这就是面向对象。在真正的 OOP 语言中，每个对象都是一个类的实例，即使是如数字和布尔值的原始值。由于在开始使用内置类型之后才实现类，所以让Zox成为真正的OOP语言会很困难。因此，原始类型的值不是类实例意义上的真实对象。它们没有方法或属性。
```Zox
>>> (1)
class Brunch < Breakfast { 
	drink() { 
		print "How about a Bloody Mary?"; 
	} 
}
>>> (2)
var benedict = Brunch("ham", "English muffin"); 
benedict.serve("Noble Reader");
>>> (3)
class Brunch < Breakfast { 
	init(meat, bread, drink) { 
		super.init(meat, bread); 
		this.drink = drink; 
	} 
}
```