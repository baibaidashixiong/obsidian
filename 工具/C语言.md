### 前言
- 在C语言中用`/* */`将代码直接注释掉有时候可能会因为编译器的问题而不能如愿，可以采用以下的方法（与与处理器有关）：
```c
#if 0
	statements
#endif
```
- 常量：
```c
int const *pci; // pci是一个指向整型常量的指针，可以修改指针的值，但不能修改它所指向的值。
int * const cpi; // 声明pci为一个指向整型的常量指针。此时指针是常量，它的值无法修改，但是可以修改它所指向的整型的值。
int const * const cpci; // 指针与所指都是常量，不可修改。
```
### 操作符和表达式
- 位操作：（注：有符号值的右移位操作是不可移植的，因为存在逻辑移位和算术移位）
```c
value = value | 1 << bit_number; // 将指定位设置成1
value = value & ~ ( 1 << bit_number ); // 将指定位清零
value & 1 << bit_number; // 对指定位进行测试，如已被设为1,则结果为非0
```
- 赋值
```c
a = x = y + 3; // 等同于a = ( x = y + 3); <=> x = y + 3; a = x;
r = s + ( t = u - v ) / 3; // 等价于t = u - v; r = s + t / 3;
//以下代码会出错：
//原因是EOF需要的位数(整型，4字节)比字符型(1字节，-128~127)要多，然后被截短的getchar返回值会被拓展与EOF进行比较，导致出错。
char ch;
while(( ch = getchar()) != EOF){...}
```
- 单目操作符：
```c
!取逻辑反，~取补，-取负值，+什么也不干
&操作符产生操作数的地址
int a , *b ;
b = &a; // &取变量a的地址，并把它赋值给指针变量
(float)a //将整型变量a强制转换成对应的浮点数值
>>>
a = b = 10;
c = ++a; //a增至11,c也为11
d = b++; //b增至11,但d仍为10
```
- 条件操作符：
```c
expression1 ? expression2 : expression3;
```
- 逗号操作符：逗号操作符将两个或多个表达式分隔开来，这些表达式自左向右逐个进行求值，整个逗号表达式的值就是最后那个表达式的值。
```c
expression1, expression2, ..., expressionN
>>>
a = get_value();
count_value(a);
while( a > 0 ){
	a = get_value();
	count_value( a );
}
//等价于
while( a = get_value(), count_value( a ), a > 0 ){
	...
}
//更简为
while( count_value( a = get_value() ), a > 0 ){
	...
}
```
- 下标引用和结构成员：
```c
array[n] // 下标引用
*( array + (n) ) // 间接访问，与上面等价
//. 和 ->操作符
s.a访问结构体s中的成员a，->用于访问 结构体指针 中的成员
a->b <=> (*a).b
```
- **左值**(L-value)和**右值**(R-value)：
```c
int a, *pi;
// pi 是左值， &a是右值
pi = &a;
*pi = 20;// 指针pi的值是内存中某个特定位置的地址，*操作符使机器指向那个位置，所以此处左值作为一个表达式（当其作为左值时*pi指定需要进行修改的位置，当其作为右值时它就提取当前存储于这个位置的值）
```
### 指针
- 在硬件中，每一个内存地址都包含着一个值，但是直接记地址太多笨拙，于是在高级语言中就将其抽象成变量，使得可以通过名字而不是地址来访问内存的位置。（注：名字与内存位置之间的关联并不是硬件所提供的，它是由编译器实现的）
- **间接访问操作符**：通过一个指针访问它所指向的地址的过程称为间接访问（indirection）或解引用指针（dereferencing the pointer）这个用于执行间接访问的操作符是单目操作符`*`。
```c
int a = 112, b = -1;
float c = 3.14;
int *d = &a;
float *e = &c;
>>> // 整数交换
/* 
** 交换调用程序中的两个整数
*/
void swap( int *x, int *y ){
	int temp;
	temp = *x;
	*x = *y;
	*y = temp;
}

swap ( &a, &b ); // 调用方法，因为函数期望接受的参数是指针
```
假设a的地址为100，则能得出以下表格：
|  表达式   | 右值  | 类型 |
|  :--:  | :---:  | :--: |
| a  | 112 | int |
| b  | -1 | int |
| c  | 3.14 | float |
| d  | 100 | int `*` |
| e  | 108 | float `*` |
| `*d`  | 112 | int |
| `*e`  | 3.14 | float |
这里的`*d`就是间接访问，`*`就是间接访问操作符。于是语句`*d = 10 - *d;`即等价于`a = 10 - a;`.
解释表达式`*&a = 25;`：将25赋值给变量a，首先&取变量a的地址，使`&a`成为指针常量，然后`*`操作符间接访问其操作数所表示的地址，即变量a。

- **指针初始化**：下列代码会发生内存错误（指针指向非法地址）或是更严重的错误，因为在指针初始化时未对其分配地址，在对其进行赋值的时候指针可能会指向一个合法地址，并将改地址上的值修改。所以在对指针进行间接访问前需要确保其被初始化。
```c
int *a;
*a = 12; // 间接访问
```

- **指针常量**：一般只有在需要访问确定的地址时才使用，如操作系统启动过程中的某个特定地址信息。
```c
*100 = 25; // 非法，间接访问操作只能作用于指针类型表达式
*(int *)100 = 25; // 合法，强制类型转换将100从整型转换为指向整型的指针
```

- **双指针**：`*` 操作符具有从右向左的结合性，所以`int **c`相当于`int *(*c)`，`*c`访问c所指向的位置（即变量b），第二个间接访问操作符访问该位置所指向的地址，即变量a。
```c
int a = 12;
int *b = &a;
int **c = &b; // *c指向b，*(*c)指向a
c = &b; 
```

- **算术运算**：C的指针算术运算只有两种形式：指针 +/- 整数 和 指针 - 指针。两个指针相减的结果类型是ptrdiff_t，它是一种有符号整数类型，减法运算的值是两个指针在内存中的距离（以数组元素的长度为单位，而不是以字节为单位）如指针p1指向`array[i]`，p2指向`array[j]`，则p2-p1的值就是j-i的值。（如果两个指针所指向的不是同一个数组中的元素，则它们之间想减的结果是未定义的）
```c
// 指针 +/- 整数
int *a = &b;
*a++ = 0; // 将a所指地址的内容赋值为0再往后移一个单位，如a为int指针则后移4个字节
```

### 函数
- **函数原型**：函数原型告诉编译器函数的参数数量和每个参数的类型以及返回值的类型，编译器见过原型后，就可以检查该函数的调用，确保参数正确、返回值无误。使用原型最方便且安全的方法是把原型置与一个单独的文件，当其他源文件需要这个函数的原型时就使用 `#include` 指令包含该文件，这样简化了程序的维护任务。（注：当程序调用一个无法见到原型的函数时，编译器便认为该函数返回一个整型值）
```c
//分号区分了函数原型和函数定义的起始部分
int *find_int( int key, int array[], int len ); 
>>>// 使用函数原型的方法，func.c
#include  "func.h"
void a(){
	...
}
void b(){
	...
}
>>> // func.h
int *func( int *value, int len );
```
- **可变参数列表**：
	- 可表参数列表通过 `stdarg.h` 头文件中的stdarg宏来实现，它是标准库的一部分。这个头文件声明了一个类型va_list和`va_start, va_arg, va_end`三个宏。列表参数中的省略号表示此处可能存在传递数量和类型未确定的参数。
	- 函数声明了一个名叫`var_arg`的变量用于访问参数列表的未确定部分，这个变量通过调用`va_start`来初始化。`va_list`类型用于声明一个变量，该变量将依次引用各参数，可以将其理解为“参数指针”类型的变量；`va_start`将参数指针初始化为指向第一个无名参数的指针；`va_arg`每次调用都将返回一个参数，并将参数指针指向下一个参数；`va_end`是必须的，它将完成一些必要的清理工作。
```c
// 计算指定数量的值的平均值
#include <stdatg.h>
float average( int n_values, ... ){
	va_list multiargs;
	int count;
	float sum = 0;
	// 准备访问可变参数
	va_start( multiargs, n_values );
	// 添加取自可变参数列表的值，并为其指定类型
	for( count = 0; count < n_values; count += 1 ){
		sum += va_arg( multiargs, int )
	}
	// 完成处理可变参数
	va_end( var_arg );
	return sum / n_values;
}
```

- **ADT和黑盒**：C可以用于设计和实现**抽象数据类型(ADT, abstract data type)**，也称黑盒。因为其可以限制函数和数据定义的作用域。限制对模块的访问是通过static关键字的合理使用实现的，它可以限制对并非接口的函数和数据的访问。例如维护一个地址/电话号码列表的模块，模块必须提供函数，根据一个指定的名字查找地址和电话号码。但是列表存储的方式是依赖于具体实现的，可以加上static关键字来将其私有，使得外部用户无法直接访问和模块实现有关的数据。

### 数组
- C语言中**数组名的值是一个指针常量**，也就是数组第1个元素的地址。只有在两种场合下，数组名并不用指针常量来表示：1. 就是当数组名作为sizeof操作符。 2.单目操作符&的操作数。sizeof返回整个数组的长度，而不是指向数组的指针的长度。
```c
int a[10];
int b[10];
...
c = &a[0];
c = a; // 与上面语句等价，a表示数组a[10]的第一个元素的地址
b = a; // 非法，不能直接复制整个数组，只能循环复制每一个元素
a = c; // 非法，a的值是常量，不能被修改
```
- **指针与下标**：