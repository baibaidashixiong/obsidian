本笔记以IA-32体系为例
## 汇编语言程序设计环境基础
### 概述
- **指令码格式**：IA-32指令码格式由四个主要部分构成：
	- 指令前缀（可选），包含下面4组：
		- 锁定前缀：表示指令将独占地使用共享内存区域。重复前缀：表示重复的功能。
		- 段覆盖前缀：定义可以覆盖定义的段寄存器的指令。分支提示前缀：尝试向处理器提供程序在条件跳转语句中最可能的路径的线索。
		- 操作数长度覆盖前缀：通知处理器在该操作码内切换操作数长度。
		- 地址长度覆盖前缀：通知处理器程序将切换内存地址位数。
	- 操作码（opcode）（必选）：每个指令码**必须**包含的部分，定义处理器执行的基本功能或任务。
	- 修饰符（可选）：一些操作码需要另外的修饰符来定义执行的功能中涉及到什么寄存器和内存位置。
	- 数据元素（可选）：一些指令码从内存位置或者处理器寄存器读取数据，而一些指令码在其本身之内包含数据。该值常用于表示静态数字值或者内存位置。
```bash
                  |<-    修饰符    ->|
[指令前缀] [操作码] [Mod/M] [SIB] [移位] [数据元素]
[0~4字节] [1~3B]  [0~1B]  [0~1B] [0~4B][0~4B]
```
- **操作码助记符**：如push，mov，sub，call等。
```asm
# 指令码
55
89 E5
83 E3 08
C7 45 FC 01 00 00 00
83 EC 0C
6A 00
E8 D1 FE FF FF
# 汇编语言代码/助记符
push %ebp
mov  %esp, %ebp
sub  $0x8, %esp
movl $0x1, -4(%ebp)
sub  $0xc, %esp
push  $0x0
call  8048348
```
- **命令（Assembler Directives，伪指令）**：以下的`.long, .ascii, .float`命令用于通知汇编器来声明一个特定的数据类型。汇编语言中使用最重要的命令之一就是`.section`命令，其定义了内存段，汇编语言在其中定义元素，三个最常用的段如下：
	- 数据段：用于声明为程序存储数据元素的内存区域，在整个程序中保持静态。（可选）
	- bss段：也是静态的内存段，包含用于以后在程序中声明的数据的缓冲区，该段落的特殊之处是缓冲区内存区域是由0填充的。（可选）
	- 文本段：是内存中存储指令码的区域，其也是固定的，其中只包含汇编语言程序中声明的指令码。（必选）
```asm
testvalue: # 声明数据元素
	.long 150
message:
	.ascii "This is a test message"
pi:
	.float 3.14159
```

### IA-32平台
#### IA-32处理器的核心部分
处理器包含控制计算机操作的硬件和指令码，通过使用3个单独的总线：**控制总线**（用于保持处理器和各个系统元素之间功能的同步）、**数据总线**（用于在处理器和外部系统元素之间传送数据）和**地址总线**（处理器把内存地址放置于此，内存存储单元作出响应，把这个内存位置存储的值放到数据总线上以便处理器进行访问）。
- **处理器组成部分**：（下图显示了这些组件以及它们如何在处理器内进行交互）
	- **控制单元**：处理器的中心。主要作用是控制处理器在任何时候进行什么操作。从内存获得指令并加载它们以便处理。指令计数器从内存获得下一条指令码并且使之准备好进行处理。指令解码器用于把获得的指令码解码为微操作。微操作是控制处理器芯片之内的特定信号来执行指令码的功能的代码。
	- **执行单元**：处理器的主要功能。由一个或多个运算逻辑单元（ALU）构成。
	- **寄存器**：可以理解为处理器内部的内存。包含以下几种寄存器：
		1. 通用寄存器：用于临时地存储数据。其中EAX用于操作数和结果数据的累加器，EBX指向数据内存段中的数据的指针，ECX是字符串和循环操作的计数器，ESP是堆栈指针，EBP是堆栈数据指针。
		2. **段寄存器**：专门用于引用内存位置。包括**平坦内存模式**（全部系统内存表示为**连续**的地址空间）、**分段内存模式**（系统内存被划分为独立段段组，通过位于段寄存器中的指针进行引用，如一个段包含指令码，另一个段用于包含数据元素，第三个段用于包含程序堆栈）和**实地址模式**。段寄存器：CS（代码段，即内存中存储指令码的位置），DS（数据段），SS（堆栈段），ES/FS/GS（附加段指针）。
		3. 指令指针寄存器（EIP），也被称为程序计数器（program counter），其跟踪要执行的下一条指令码。
		4. 控制寄存器（CR0-CR4）：用于确定处理器的操作模式还有当前正在执行的任务的特性。（类似RISCV中CSR控制和状态寄存器）
	- **标志**：用于确定处理器中实现的每个操作是否成功的机制。
```bash
|—------|     |------|<---->[寄存器]
|控制单元|<--->|执行单元|
|-------|     |------|<----> [标志]
```
- **超线程**：超线程技术由位于单一物理处理器中的两个或者多个逻辑处理器构成。**每个逻辑处理器**都包含通用、段、控制和调试寄存器的完整集合。所有逻辑处理器共享相同的执行单元，乱序执行引擎负责处理不同逻辑处理器提供的独立线程的指令码。

### 相关工具
#### 开发工具
- **汇编器**：汇编器将汇编语言程序转换成目标文件（.obj），其包括机器语言指令、伪指令数据和指令正确放入内存所需要的信息，汇编器将分支和数据传输指令中用到的标号都放入一个**符号表**中。GUN汇编器（被称为gas，命令行可执行程序称为as）是unix环境中可用的最为流行的跨平台汇编器，gas的一个独特特性是能够创建不同于程序设计所在平台的平台的指令码（类似交叉编译）
	- **HLA（High Level Assembler, HLA）**：高级汇编器。
	- **伪指令**：汇编语言指令的一个变种，通常被看作一条汇编指令。
	- **关于操作码语法**：gas汇编器采用AT&T操作码语法，与Intel操作码语法略有区别：
		- AT&T使用 $ 表示立即操作数；AT&T在寄存器名称前面加上前缀 % ；AT&T处理源和目标操作数时使用相反的顺序。把十进制值4传送给EAX寄存器，**AT&T的语法是`movl $4, %eax`，而Intel的语法是`mov eax, 4`**。
- **连接器（linker）**：gnu ld。用于把目标代码文件（obj）连接为可执行程序文件或者库文件。
- **调试器**：调试器必须了解硬件平台的指令码集合并且了解操作系统处理寄存器的内存的方法。调试器为程序员提供4个基本功能：
	- 在一个受控制的环境下运行程序，指定任何必须的运行时参数。
	- 在程序内的任何位置停止程序。
	- 检查数据元素，比如内存位置和寄存器。
	- 在程序运行时改变程序中的元素以便帮助消除缺陷。
- **编译器**：大多数编译器产生一个中间步骤，编译器将高级语言转换成汇编语言代码，然后汇编器把汇编语言代码转换为指令码。在GNU中，把C或C++源代码转换为汇编语言后，GNU编译器使用GNU汇编器生成连接器使用的指令码。可以在这两个步骤之间停下来，检查从C或者C++源代码生成的汇编语言代码。如果认为可以优化某些部分，那么可以修改生成的汇编语言代码，然后把代码汇编为新的指令码。
	- gcc中一个非常有用的命令行参数是-S参数，这个参数让编译器创建中间汇编语言文件，然后汇编器进行汇编，最终生成包含汇编语言指令的.s文件。
- **目标代码反汇编器**：反汇编程序（disassembler program）将obj文件或可执行程序转换为指令码格式，一些反汇编器能更进一步将指令码转换为容易阅读的汇编语言语法。objdump -d用于显示反汇编后的目标代码文件。
- **GNU简档器程序（gprof）**：该程序用于分析程序的执行和确定程序中的热点在什么位置，在编译时加入-pg参数以便gprof可以执行。

### 汇编语言程序范例
#### 程序的组成
汇编语言最常用的三个段：数据段、bss段、文本段。**文本段**是可执行程序内声明指令码的地方，所以其是必选的。**数据段**声明带有初始值的数据元素，这些数据元素用作汇编语言程序中的变量。**bss段**声明使用0（或null）值初始化的数据元素，这些数据元素最常用作汇编语言程序中的缓冲区。
**定义段**：GNU汇编器使用.section命令语句声明段。.section语句只使用它声明的段的类型这一个参数。
**定义起始点**：将汇编语言转换为可执行文件时，连接器必须知道指令码中的起始点是什么。GNU汇编器声明一个标识符用作应用程序的入口点，一般默认以`__start`来表明程序运行起始点，也可以使用ld的-e参数定义新的起始点的名称。除了在应用程序中声明起始标签之外，还需要为外部应用程序提供入口点，使用.globl命令完成，其声明了外部程序可以访问的程序标签。
```asm
# 汇编语言程序基础模版
.section .data
	< initialized data here >
.section .bss
	< uninitialized data here >
.section .text
.globl _start
_start:
	< instruction code goes here >
```

#### 创建简单程序
- **CPUID指令**：请求处理器的特定信息并把信息返回到特定寄存器中的低级指令。EAX寄存器决定CPUID指令生成什么信息，根据EAX寄存器段值，CPUID指令在EBX、ECX和EDX寄存器中生成关于处理器的不同信息。示例程序：
```asm
# cpuid.s
.section .data
output:
	.ascii "The processor Vendor ID is 'xxxxx'\n" 
	# 在数据段中声明字符串，后面的x在保留给数据变量的内存区域中作为占位符
.section .text        # 声明程序的指令码段
.globl _start         # 声明起始标签
_start:
	movl $0, %eax     # 使eax加载零值然后运行CPUID指令
	cpuid
movl $output, %edi    
# 创建一个指针，当处理内存中声明的output变量时会使用这个指针。并将output标签的内存位置被加载到EDI寄存器中
movl %ebx, 28(%edi)   # 将ebx中的内容放到edi寄存器偏移量28个字节的地址
movl %edx, 32(%edi)
movl %ecx, 36(%edi)
movl $4, %eax         # 表明系统调用号为4
movl $1, %ebx         # ebx表示文件描述符，stdout的文件描述符为1
movl $output, %ecx    # ecx字符串的开头
movl $42, %eax        # edx字符串的长度
int $0x80             # 软件中断，从内核访问控制台显示
movl $1, %eax         # 系统调用号1（退出函数）
movl $0, %ebx         # ebx包含程序返回给shell的退出代码值
int $0x80
```
- **构建可执行程序**：有了汇编语言源代码程序，可以使用GNU汇编器和GNU连接器构建可执行程序：
```bash
as -o cpuid.o cpuid.s
ld -o cpuid cpuid.o
./cpuid # 运行可执行程序
```
- **使用编译器进行汇编**：可以使用GNU通用编译器（GNU Common Compiler，gcc）在单一步骤内汇编和链接汇编语言程序。而GNU连接器ld是查找`_start`标签来确定程序的开始位置，但gcc查找的是main标签，所以必须把程序中的_start标签和定义标签的.globl命令都改成：
```asm
.section .text
.globl main
main:
	...
>>>
gcc -o cpuid cpuid.s # 合并汇编和连接
./cpuid              # 运行程序
```
##### 调试程序：
- **调试程序**：在汇编时指定`-g/-gstabs`参数来附加信息到可执行程序文件中。
	1. **单步运行程序**：在汇编语言程序中指定断点时，必须指定对于最近的标签的相对位置，break命令的格式是：**`break *(label+offset)`**。如在_start标签后加上一条NOP伪指令（用于对汇编过程进行控制的非可执行指令）后`break *_start+1`就可以成功在_start处打上断点并开始调试。n/next和s/step都能执行下一行源代码，但是当所执行代码行中包含函数时step会跳入。c/cont/continue使程序继续执行到下一个断点处。
	2. **查看数据**：
		- info registers：显示所有寄存器的值。
		- print：显示特定寄存器或者来自程序的变量的值。
			- print/d显示十进制的值，print/t显示二进制的值，print/x显示十六进制的值。`print/x $ebx`将寄存器ebx的值打印成十六进制格式。
		- x：显示特定内存位置。格式为`x/nyz`。其中n是要显示的字段数。
			- y是输出格式：c用于字符，d用于十进制，x用于十六进制。
			- z是要显示的字段的长度：b用于字节，h用于16位字（半字），w用于32位字。
			- `x/42cb &output`就是以字符模式（同时也显示十进制值）显示output变量的前42个字节。

## 汇编语言程序设计基础
### 传送数据
#### 定义数据元素
数据段和bss段都提供定义数据元素的方法。
- **数据段**：数据段用`.data`命令定义用来存储项目的特定内存位置，这些项目可以被程序中的指令码引用，并可以被随意读取和修改。（`.rodata`为read only只读数据段）定义数据元素需要标签（类似变量名，对处理器无意义，用于引用指针进行内存访问）和命令两个语句。
```asm
# 把定义字符串顺序放入内存字节中并把标签outpuoutput赋值为第一个字节
output:
	.ascii "The processor Vendor ID is 'xxxxx'\n"
# 类似数组，把100存放在sizes引用开始的内存，然后存放150...
sizes:
	.long 100, 150, 200, 250, 300
# 定义多个数据元素
.section .data
msg:
	.ascii "This is a test message"
factors:
	.double 0.00, 1.00, 9.99
height:
	.int 54
length:
	.int 62, 35, 45
# 内存内从低到高存放数据的顺序为54[height],62,35,45[length]
```
- **定义静态符号**：`.equ`命令把常量值设置为可以在文本段中使用的符号：
```asm
.equ factor, 3
.equ LINUX_SYS_CALL, 0x80
movl $LINUX_SYS_CALL, %eax # 注意加符号$
```
- **bss段**：bss段无需声明特定的数据类型，只需声明所要保留的原始内存部分即可。GNU汇编器使用以下两个命令声明缓冲区，它们的格式是`.comm symbol, length`，symbol是赋给内存区域的标签，length是内存区域中包含的字节数量。
	- `.comm`：声明未初始化的数据段通用内存区域。
	- `.lcomm`：声明未初始化的数据段**本地**通用内存区域。
```asm
.secton .bss
.lcomm buffer, 1000 # 将1000字节的内存区域赋值给buffer标签（l表示不能在.globl中使用）
```
	在bss段中声明数据的一个好处是数据不包含在可执行程序中。数据data段定义数据时必须被包含在可执行程序中，因为必须使用特定值将其初始化。而bss段中声明的数据区域不需要被初始化，所以内存区域被保留在运行时使用。默认情况下bss段为数据的所有字节赋值为零。

#### 传送数据元素
- **mov指令格式**：`movx source, destination`，source和destination可以是内存地址、内存中的数据值、指令语句中定义的数据值，或者是寄存器。其中x可以是：
	- l用于32位的长字值
	- w用于16位的字值
	- b用于8位的字节值
- **把立即数传送到寄存器和内存**：需要在每个值前面都加上`$`符号表明其是立即数。（在标签前加`$`则指示内存地址）
```asm
movl $0, %eax       # 将值0传送到eax寄存器
movl $0x80, %ebx    # 将十六进制80传送到ebx寄存器
movl $100, height   # 将值100传送到height变量所在的内存地址
```
- **在寄存器之间传送数据**：8个通用寄存器（EAX、EBX、ECX、EDX、EDI 、ESI 、EBP和ESP）可以将其内容传送给可用的任何其他类型的寄存器。但专用寄存器（控制、调试和段寄存器）的内容只能传送给通用寄存器或从其接收。
```asm
movl %eax, %ecx
movl %ax, %cx
```
##### 在内存和寄存器之间传送数据
1. 把数据值从内存传送到寄存器：用于把变量标签指定的内存位置的数据值传送给EAX寄存器。如果数据长度小于4字节，可以用MOVB传送1字节，或者MOVW传送2字节。
```asm
.section .data
	value:
		.int 1
.section .text
.globl _start
	_start:
		nop
		movl value, %ecx # 传送从value标签引用的内存位置开始的4字节数据
		movl $1, %eax
		movl $0, %ebx
		int $0x80
```
2. 将数据值从寄存器传送给内存：
```asm
# 定义value为int
_start:
	movl $100, %eax
	movl %eax, value
	movl $1, %eax
	movl $0, %ebx
	int $0x80
```
3. **使用变址的内存位置**：由于一个命令指令可以将多个值放到内存中，每个数据值都占用内存的一个单元，于是引用数组中的每个数据必须使用变址内存模式来确定要访问的值。内存位置由**基址、添加到基址上的偏移地址、数据元素的长度**几个因素决定，表达式为：`base_address (offset_address, index, size)`，获取的数据值内存地址为：`base_address + offset_address + index * size`。其中`offset_address`和`index`的值必须是寄存器，但是`size`的值可以是数字值。
```c
values:
	.int 10, 15, 20, 25, 30, 35, 40, 45, 50
movl $2, %edi
movl values(, %edi, 4), %eax
# 把values标签开始的第3个4字节的变址值加载到EAX寄存器中，此时eax中的值为20
```
4. **使用寄存器间接寻址**：除了保存数据之外，寄存器也可以用于保存内存地址。当寄存器保存内存地址时，它被称为指针，使用指针访问存储在内存位置中的数据称为间接寻址（indirect addressing）。
```c
movl $values, %edi // 把values标签引用的内存地址传送给edi
movl %ebx, (%edi)  // 加上括号后，把ebx寄存器的值传送给edi寄存器中包含的内存位置
movl %edx, 4(%edi) // 把edx寄存器中的值存放在edi寄存器指向位置之后4个字节的内存位置中
```
示例程序：
```c
.section .data
values:
	.int 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60
.section .text
.globl _start
_start:
	movl values, %eax   // eax中为10
	movl $values, %edi  // edi中为values标签的内存地址
	movl $100, 4(%edi)  // 100取代edi后4个字节的内容（即15）
	movl $1, %edi
	movl values(, %edi, 4), %ebx // 数组的第二个数据元素加载到EBX寄存器中
	movl $1, %eax       // 退出系统调用号
	int $0x80           // 'echo $?'则打印100
```
##### 条件传送指令
- **使用CMOV指令**：查找values数组中定义的一系列整数中最大的一个。
```c
.section .data
output:
	.asciz "The largest value is %d\n"
values:
	.int 105, 235, 61, 315, 134, 221, 53, 145, 117, 5
.section .text
.globl _start
_start:
	movl values, %ebx // ebx保存当前找到的最大整数
	movl $1, %edi
loop:
	movl values(,%edi,4), %eax
	cmp %ebx, %eax    // 看eax-ebx的正负
	comva %eax, %ebx  // eax>=ebx则取而代之
	inc %edi          // edi自增1
	cmp $10, %edi
	jne loop          //jump if not equal
	pushl %ebx
	pushl $output
	call printf
	addl $8, %esp
	pushl $0
	call exit
```
- **使用数据交换指令**：以冒泡排序算法为例。在汇编语言中是使用一个数据数组和两个计数器（EBX和ECX）实现的。EBX用于内层循环，ECX用于外层循环。
```c
>>> # 高级语言实现
for(out = array_size-1; out>0, out--)
{
	for(int = 0; in < out; in++)
		if(array[in] > array[in+1])
			swap(array[in],array[in+1])
}
>>> # 汇编语言实现
.section .data
values:
	.int 105, 235, 61, 315, 134, 221, 53, 145, 117 ,5
.section .text
.globl _start
_start:
	movl $values, $esi
	movl $9, %ecx
	movl $9, %ebx
loop:
	movl (%esi), %eax
	cmp %eax, 4(%esi)   // 后值与前值比较？
	jge skip            //jump if greater or eq
	xchg %eax, 4(%esi)
	movl %eax, (%esi)
skip:
	add $4, %esi    //增加4字节，即指向第2个元素地址
	dec %ebx
	jnz loop
	dec %ecx
	jz end          // jump if zero ?
	movl $values, %esi
	movl %ecx, %ebx
	jmp loop
end:
	movl $1, %eax
	movl $0, %ebx
	int $0x80
```
##### 堆栈
- **堆栈的工作方式**：普通的数据元素按照连续的方式存放到数据段中，在数据段中从最低的内存位置开始，向更高的内存位置依次存放，而且可以支持随机访问。而堆栈的行为正好相反，堆栈起始位置被保留在**内存的高地址**处，当数据被存入到堆栈中时会向下增长，并用ESP寄存器指针指向堆栈的最高处（即堆栈的最低内存地址处），此处又被称为堆栈的起始地址。（EBP经常用作堆栈的基指针，即栈中的最高内存地址处，当函数开始时通常把ESP寄存器复制到EBP指针）
- **压入和弹出数据**：压入：`pushx source`。x=l用于长字（32位），x=w用于字（16位）。IA32中push可以操作16/32位寄存器值，16/32位内存值，16位段寄存器，8位立即数值，16/32位立即数值。**弹出**：`popx destination`。可以使用16/32位寄存器，16位段寄存器，16/32位内存位置。
```c
pushl %ecx   // 压入32位寄存器ecx中的值
pushw %cx    // 压入16位寄存器cx中的值
pushl $100   // 压入值100到栈中
pushl data   // 将data标签中的值压入栈 
pushl $data  // 将data标签的内存地址压入栈
```
- **压入和弹出所有寄存器**：`PUSHA/POPA`压入或弹出所有16位通用寄存器，`PUSHAD/POPAD`压入或弹出所有32位通用寄存器。

### 控制执行流程
- **指令指针**：指令指针在程序指令中移动时EIP寄存器会递增，指针的长度可能是多个字节，所以指向下一条指令不仅仅是每次使指令指针递增1.程序不能直接用MOV指令修改EIP寄存器的值，但是通过分支指令来改动EIP的值，其又分为无条件分支和条件分支。
#### 无条件分支
- **跳转**：`jmp location`，location是要跳转到的内存地址。
- **调用**：`call address`，address操作数引用程序中的标签，它被转换为函数中的第一条指令的内存地址。调用指令的第二部分是返回指令。执行CALL指令时它把EIP寄存器的值存放到堆栈中，然后修改EIP寄存器以指向被调用的函数地址。调用函数完成后从堆栈获得过去的EIP寄存器值，并把控制权返回给原始程序。
```c
// call指令程序示例
.section .data
output:
	.asciz "This is section %d\n"
.section .text
.globl _start
_start:
	pushl $1
	pushl $output
	call printf
	add $8, %esp
	call overhere
	pushl $3
	pushl $output
	call printf
	add $8, %esp
	pushl $0
	call exit
overhere:
	pushl %ebp
	movl  %esp, %ebp // 栈基
	pushl $2
	pushl $output
	call printf
	add $8, %esp     // 相当于出栈，可省略
	movl %ebp, %esp
	popl %ebp
	ret
// 输出
This is section 1
This is section 2
This is section 3
```
- **中断**：当 一个程序被中断调用时，发出调用的程序暂停，被调用的程序接替它运行 。指令指针转移到被调用的程序，并且从被调用的程序内继续执行。被调用的程序完成时，使用中断返回指令把控制返回给发出调用的程序。
	- 软件中断：由os提供，使应用程序可以使用os内的函数，如`int $0x80`中断用于提供低级内核函数。中断发生时按照EAX寄存器的值执行子函数。
	- 硬件中断：如时钟信号，I/O中断等。

#### 条件分支
条件分支的结果取决于执行分支时EFLAGS寄存器的状态。其只与EFLAGS寄存器中的5位有关：
	进位（Carry）标志（CF）——第0位
	溢出（Overflow）标志（OF）——第11位
	奇偶校验（Parity）标志（PF）——第2位
	符号（Sign）标志（SF）——第7位
	零标志（ZF）——第6位
- **条件跳转指令**：`jxx address`，其中xx是1个到3个字符的条件代码，address是程序要跳转到的位置（通常以标签标识）。以下为IA32的所有条件跳转指令：
![[条件跳转指令.png]]
其中对于计算无符号整数值，跳转指令使用above和below关键字；对于带符号整数值，使用greater和less。条件跳转允许使用8位带符号地址偏移量的短跳转和16或32位带符号地址偏移量的近跳转。条件跳转不支持分段内存模式下的远跳转。
- **比较指令**：`cmp operand1, operand2`，其对两个操作数进行减法操作：operand2-operand1，并设置EFLAGS寄存器。
```c
.section .text
.globl _start
_start:
	movl $15, %eax
	movl $10, %ebx
	cmp %eax, %ebx
	jge greater
	movl $1, %eax
	int $0x80
greater:
	movl $20, %ebx
	movl $1, %eax
	int $0x80
// 结果，ebx小于eax，不跳转
$ echo $?
10
```
- **使用标志位范例**：
	- **使用零标志**：`jz location`。如果零标志被置1（两个操作数相等或寄存器中值为0），JE和JZ指令就跳到分支，零标志可以由CMP指令设置，也可以由计算结果为零的数学指令设置。
	- **使用溢出标志**：`jo location`。
	- **使用奇偶校验标志**：`jp location`。二进制表示中设置为1的位数（如00000011）是偶数个则PF设为1，否则（如00000001）为0.
	- **使用符号标志**：`jns location`。用于检查寄存器值的符号改变，符号改变时不跳转。
	- **使用进位标志**：`jc location`。其中DEC和INC指令不影响进位标志。

#### 循环
- **循环指令**：`loop address`。循环的好处是会递减ECX寄存器的值而不影响EFLAGS寄存器的标志位，当寄存器值达到零时零标志不会被设置。
	- LOOP：循环直到ECX寄存器为零。
	- LOOPNZ/LOOPNE  Lable：ECX--，若(CX)!=0且ZF=1，则转移到Lable
	- LOOPNE/LOOPNZ：循环直到ECX寄存器为零且ZF=0。
```c
# 计算从1加到100
.section .data
outpput:
	.asciz "The value is: %d\n"
.section .text
.globl _start
_start:
	movl $100, %ecx
	movl $0, %eax
loop1:
	addl %ecx, %eax
	loop loop1
	pushl %eax
	pushl $output
	call printf
	add $8, %esp
	movl $1, %eax
	movl $0, %ebx
	int $0x80
```
- **防止LOOP灾难**：以上程序会在ecx设置为0时出错，因为当执行loop指令时会先把ECX中的值递减1，然后再检查ECX的值是否为0.当ECX本身为0时，loop检查时就会为-1，ECX便会不断--直到寄存器溢出并显示错误的值，所以需要检查ECX寄存器包含零值时的特殊条件。可以用JC XZ指令（如果ECX为0则跳转）执行条件分支。
```c
.section .data
outpput:
	.asciz "The value is: %d\n"
.section .text
.globl _start
_start:
	movl $0, %ecx
	movl $0, %eax
	jcxz done // 检测到ecx为0则直接退出
loop1:
	addl %ecx, %eax
	loop loop1
done:
	pushl %eax
	pushl $output
	call printf
	movl $1, %eax
	movl $0, %ebx
	int $0x80
```

#### 优化分支指令
- **分支预测**：
	- **无条件分支**：对于无条件分支不难确定下一条指令，但是远跳转可能导致下一条指令不在当前指令预取缓存中，如果新指令不在缓存中，那么必须清空整个预取缓存然后从新的位置重新加载指令。这对程序的性能而言代价很高。
	- **条件分支**：对于每个条件分支，分支预测单元必须预测是否采用该分支，最简单的就是静态预测，即认为所有分支都会跳转，即预取if then的部分和for的下一部分（可以通过此特性来对程序进行优化），但是对于选择语句预测率会较低。
- **优化技巧**：
	- **消除分支**：如COMVA指令，会检查CMP指令的结果，根据cmp结果来调用comva指令，来减少跳转。也可以重复几个额外指令来消除跳转。小的指令开销更适合指令预取缓存，从而补偿跳转本身造成的性能影响。
	- **编写可预测分支的代码**：对于向前跳转（向程序结束方向）的指令（如if else）采用的代码安排在向前跳转的顺序执行语句中（如放在if then的地方），会提高它在指令预取缓存中的可能性。对于向后分支（程序开始方向）的代码（如for循环），试图用向后分支路径作为最可能被采用的路径。
	- **展开循环**：对于比较小的循环可以展开循环来取消指令预测的次数。但是也要小心展开过多的指令会过度地填充预取缓存，这将迫使处理器不断填充和清空预取缓存。

### 使用数字
**核心数字数据类型**包括：无符号整数、带符号整数、二进制编码的十进制数、打包的二进制编码的十进制、单精度浮点数、双精度浮点数、双精度扩展浮点数。**高级数字数据类型**：64位打包整数、128位打包整数、128位打包单精度浮点数、128位打包双精度浮点数。
#### 整数
- **标准整数长度**：IA32支持4中不同整数长度：字节（8位），字word 16位，双字double word 32位，四字quad word64位。在小端cpu中，存储在内存中超过1字节的整数称为小尾数（little-endian）格式，即低位字节存储在最低的内存位置，其余字节顺序地存储在它之后。但是将整数值传给寄存器时值会按照大尾数（big-endian）格式存储在寄存器中。
- 无符号整数
- **带符号整数**：计算机中可以通过带符号数值，反码，补码来描述负数。
- **扩展整数**：在处理不同长度的带符号整数，如将某个值传送到长度大一些的位置（比如将字传给双字），往往会有一些问题需要解决。
	 - **扩展无符号整数**：将无符号整数值转换为位数更大的值时必须确保所有高位部分都被设置为零。
		 MOVZX指令：`movzx source, destination`。source可以为8或16位寄存器或内存位置，destination可以是16或32位寄存器。
	 - **扩展带符号整数**：对于带符号整数，使用零填充高位会改变负数的数据值，如-1（补码为11111111）传给双字会生成值0000000011111111，此时的补码表示+127.对于带符号扩展，新添加的位必须被设置为1.使用MOVSX指令来完成该目标。
```c
# 扩展无符号整数
movw %ax, %bx // 不能保证ebx高位为零
// 正确做法
movl $0, %ebx
movw %ax, %ebx
```
- **在GNU汇编器中定义整数**：`.int/.short/.long`命令定义双字的带符号整数值，还可以用`.quad`命令创建四字带符号整数值。`.quad`命令可以定义一个或多个带符号整数值，但是为每个值分配8个字节。
```c
// quad
.section .data
data1:
	.int 1, -1, 463345, -333252322, 0 // 5个双字带符号整数数组
data2:
	.quad 1, -1, 463345, -333252322, 0 //5个四字带符号整数数组
.section .text
.globl _start
_start:
	movl $1, %eax
	movl $0, %ebx
	int $0x80
```

#### 二进制编码的十进制
二进制编码的十进制（Binary Coded Decimal，BCD）是按照二进制格式对十进制数字进行编码，每个BCD值都是一个无符号8位整数，范围为0-9，BCD允许单一字节包含两个BCD值。如`0001 0100 1000 1001`表示十进制数1489。但是BCD效率不高，4个字节只能表示0-9999的数字，而无符号整数4个字节可以表示最大值为4 292 967 295.
- **FPU BCD值**：`fbld source`用于把打包80位的BCD值传送到FPU寄存器堆栈中，其中source是80位的内存位置。FPU寄存器的方式和使用通用寄存器稍微有些区别。8个FPU寄存器的行为类似于内存中的堆栈。可以把值压入和弹出FPU寄存器池。ST0引用位于堆栈顶部的寄存器。当值被压入FPU寄存器堆栈时，它被存放在ST0寄存器中，ST0中原来的值被加载到ST1中.
```c
.section .data
data1:
	.byte 0x34, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	// 小尾数创建十进制1234的BCD值
data2:
	.int 2
.section .text
.globl _start
_start:
	fbld data1 // 加载data1到FPU寄存器堆栈顶部ST0
	fimul data2
	// fimul将ST0和data2所在内存位置的整数相乘
	fbstp data1
	// 把堆栈中新的值传送回data1所在的内存位置中

	movl $1, %eax
	movl $0, %ebx
	int $0x80
```

#### 浮点数
##### 浮点数概念
- **浮点格式**：浮点格式使用科学技术法表示实数，科学计数法把数字表示为系数（coefficient，也称尾数mantissa）和指数（exponent）。在十进制领域中指数的基数值为10。
- **二进制浮点格式**：系数和指数都基于二进制值。系数值`1.0101*2^2 = 101.01`，其生成十进制值5.25。
| 二进制| 十进制分数|十进制值 |
|--|--|--|
| 10.101|2+1/2+1/8 |2.625|
|10011.001|19+1/8|19.125|
|10110.1101|22+1/2+1/4+1/16|22.8125|
|1101.011|13+1/4+1/8|13.375|
- **标准浮点数据类型**：IEEE标准754浮点标准使用3个成分把实数定义为二进制浮点值：
	- 符号：符号位中1表示负值，0表示正值。
	- 有效数字：有效数字部分表示浮点数的系数。当二进制值被规格化时其表示为小数点前有个1.
	- 指数：表示浮点数的指数部分，因为指数值可以是正值也可以是负值，所以通过一个偏差值对它进行置偏。这样确保数字段只能是无符号正整数。这还限制了这种格式中可用的最小和最大指数值。
```bash
# 单精度 32位，最高位为符号位
31    30        23 22                   0
-----------------------------------------
|[符号]|[  指数  ]| |[      有效数字      ]|
-----------------------------------------

# 双精度 64位，最高位为符号位
63    62        52 51                     0
-----------------------------------------
|[符号]|[  指数  ]| |[      有效数字      ]|
-----------------------------------------
```
	单精度浮点数使用23位有效数宇值。但是，浮点格式假设有效数宇的整数值永远是1，并且在有效数字值中将它省略。这样实际上使有效数字的精度达到了24位。

- **传送浮点值**：`fld source`，将浮点值传入和传出FPU寄存器。
```c
.section .data
value1:
	.float 12.34       // 4字节单精度浮点数
value2:
	.double 2353.631   // 8字节双精度浮点数
.section .bss
	.lcomm data, 8
.section .text
.globl _start
_start:
	flds value1        // 将浮点数value1加载到FPU寄存器栈顶
	fldl value2        // ST0:value2, ST1:value1
	fstl data          // 获取FPU寄存器栈顶ST0的值
	movl $1, %eax
	movl $0, %ebx
	int $0x80
```

### 基本数学功能
#### 整数运算
- **加法**：`add source, destination`，其中source可以是立即值、内存位置或者寄存器。destination参数可以是寄存器或者内存位置中存储的值，结果存放在destination。add助记符可以在结尾添加b（字节）、w（字）、l（双字）来指定操作数的长度。
```c
.section .data
data
	.int 40
.section .text
.globl _start
_start:
	movl $0,  %eax
	movl $0,  %ebx
	movl $0,  %ecx
	movb $20, %al
	addb $10, %al
	movsx %al, %eax    // 将AL寄存器的带符号整数值扩展到EAX寄存器
	movw $100, %cx     // ecx=100
	addw %cx, %bx 
	movsx %bx, %ebx    // ebx=100
	movl $100, %edx 
	addl %edx, %edx    // edx=200
	addl data, %eax    // eax=70
	addl %eax, data    // data=110
	movl $1, %eax 
	movl $O, %ebx
	int $0x80
```
- 检测进位或者溢出情况：整数相加时应该注意EFLAGS寄存器以便确保操作过程中减少错误发生。
- ADC指令：`adc source, destination`.当数据很大，不能存放到双字数据长度，可以将值分割为多个双字数据元素，并且对每个元素执行独立的加法操作。

- 减法：
- **SUB指令**：`sub source, destination`。destination的值减去source的值，结果储存在destination中。
- **SBB指令**：`sbb source, destination`。使用进位情况帮助执行大的无符号整数值的减法操作。

- **递增和递减**：`dec destination/ inc destination`。INC和DEC指令用于对无符号整数值进行递增和递减操作，其不会影响EFLAGS寄存器和进位标志，所以可以用于计算计数器的值。
##### 乘法
- **使用MUL进行无符号整数乘法**：MUL指令用于两个无符号整数相乘。